/*--- General Info ---*/
/*Favicon color: rgb(52, 175, 78);*/


/*--- locationchange Event Listener Explanation ---*/
/*You can arrive at a page either externally or internally. If we're arriving externally we
don't have control of where to direct them, and if they try to access the wrong page 
for their screen size, we need to have some logic to take that request and route them
elsewhere. We accomplish this using React Router DOM's navigate object.*/

/*This works well but we still need logic to determine where we should direct someone
internally, to one page or another, based on some factors (for our purposes that factor is
screen size but it could be other factors). Well we could rely on React Router Dom's
logic for this and just always link to one page. Assuming our redirect logic is standard for 
this component as it is in the App level routes then it should redirect just fine.
  - Although relying on app level redirecting would create a single source of truth for
  our redirect logic, it ends up reducing SEO, and still initially renders the wrong page.*/

/*The solution would be to conditionally redirect based on some logic or state that
the component is privy to. In our case that piece of state would be the screen-size.
This is the reason why we store our screen size in our Global State, so 
we can access it from any component that might need to make a conditional redirect based
on that information.*/

/*Well if redirects happen with screen size logic, and that screen size is in our
global state so if it changes it will force a rerender on all relevant components, then
why should we also have a global state for the location info? I mean afterall, if we
want to know what page we're on we can just look at the screen size and deduce it from
there right? Well not quite
  - We want this app to be as extensible and scalable as possible. Right now we're only
  doing redirects and conditional routing based on screen size, but what if that changes
  in the future.
  - There's also a greater chance for disconnect or bugs as we're assuming all
  other components have correctly routed you to this page based on the correct logic.
  - Essentially we want an answer thats closer to the truth, which for us would be our
  page global state which is set with the custom event 'locationchange'. This allows
  us to:
    1. Rerender relevant components based on locationchange (therefore forces the 
    component to have the most up to date info on its page) (were we rerendering based
    on screen size alone we may have missed any locationchanges due to other logic)
    2. Have the most accurate source of our page information in relevant components 
    (rather than relying on screen size as a proxy to calculate our page info)*/
    
/*All in all, I'm still not 100% sure if url redirects based on screen size is best
practice and what other implications this could have (SEO, crawling, UI/UX, etc.). However,
it's a clever solution for now and I will continue to research this going forward.*/


/*--- Multi Day Header Scrollbar Offset ---*/
/*Essentially, the main challenge with this one is the fact that different browsers
have different scrollbar width's. The main content in the Multi Day page has a scrollbar,
therefore its content is offset to the left by that scrollbar's width. The header however
doesn't have a scrollbar, so even once we've offset the header by the timescale width 
(available via a global css variable) we still run into the header and the content being
misaligned.

In order to solve this we essentially need to add another element on the right to offset
the header and this offset element needs to have the same exact width of the scrollbar
in the content below it. Thus the content below the header is offset to the left due to
the scrollbar and the content in the header is offset to the left due to this offset 
element.

Now in order to get as close to the source of truth as possible it could be done so that
the offset width is calculated based on the width of the scrollbar in the main content.
However this seperates Multi-Day Header logic from the Multi Day Header component and 
seeing how the scrollbar's almost never varies within the same browser, it didn't seem 
necessary to base the offset element's width on the specific scroll bar in the
Multi-Day content div. Instead a transparent div is initially rendered in the header with
a scrollbar, once that scrollbar width has been calculated, the component rerenders
with the corrent content and offset.*/


/*--- Getting Creative with the Borders ---*/
/*An interesting challenge I ran into while constructing the Multi-Day view was
the problem of aligning each and every component that wasn't already in some shared
div. This included the TimeScale component on the left, the MultiHeader component
on top, and then the MultiDays grid in the middle.

None of these components were nested in a way so as to allow easy css styling with flexbox
or grid. I made this concious decision in order to stay as true as possible to React and
thinking in React terms. While I could have broken up, say for example the MultiHeader 
component, and taken its pieces and put them in another component with which it needed to
be aligned with, this would have been very counter intuitive from a UI perspective.
Afterall, a header is very clearly a component, doesn't it seem a bit off if under the hood
the one component we call a header is actually being constructed by 7 different pieces 
all from other components?

For those reasons above I decided to keep these components as seperate distinct components,
however now the problem became: How can I ensure that all of these seperate components
line up with each other down to the pixel? Well the short answer is, I didn't. 

After hours of trying to get every single little pixel line up I realized that I was making
things harder than I needed to be. Instead of trying to line up two seperate things, why
don't I instead have one component of this table (not referring to an html table here, 
just that the multi day view looks like a table) as the source of truth and when I need to 
do little stylings down to the pixel I'll just create an element inside of the source of 
truth and move it with absolute positioning so its outside of its parent container!

This is essentially what I did in order to have all the divisional borders on the Multi
Header line up with all the borders in the Multi Day grid. I also relied on this to line
up the cosmetic lines on the timescale component with the borders in the Multi Day grid.
All in all a fun little trick I discovered that could certainly be handy in the future!*/


/*--- General ---*/
//Framer Motion was the easiest React animations library that I found.
//Resource for animating routes with Framer Motion:
//  -https://www.youtube.com/watch?v=Imyi2V7WgGU&ab_channel=TheNetNinja